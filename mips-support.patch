diff --git a/linux-user/main.c b/linux-user/main.c
index d0e0e4f..611882f 100644
--- a/linux-user/main.c
+++ b/linux-user/main.c
@@ -34,6 +34,7 @@
 #include "qemu-timer.h"
 #include "envlist.h"
 #include "elf.h"
+#include <sys/resource.h>
 
 #define DEBUG_LOGFILE "/tmp/qemu.log"
 
@@ -3405,6 +3406,17 @@ int main(int argc, char **argv, char **envp)
         fprintf(stderr, "Unable to find CPU definition\n");
         exit(1);
     }
+    
+#if defined(TARGET_MIPS)
+    {
+		//Set OPEN_MAX on 1024
+		struct rlimit rlim1;
+		rlim1.rlim_cur=1024;
+		rlim1.rlim_max=1024;
+		setrlimit(5, &rlim1);
+	}
+#endif //#if defined(TARGET_MIPS)
+    
 #if defined(TARGET_I386) || defined(TARGET_SPARC) || defined(TARGET_PPC)
     cpu_reset(ENV_GET_CPU(env));
 #endif
diff --git a/linux-user/syscall.c b/linux-user/syscall.c
index 539af3f..e6e762b 100644
--- a/linux-user/syscall.c
+++ b/linux-user/syscall.c
@@ -96,6 +96,7 @@ int __clone2(int (*fn)(void *), void *child_stack_base,
 #include <linux/fb.h>
 #include <linux/vt.h>
 #include <linux/dm-ioctl.h>
+#include <sys/epoll.h>
 #include "linux_loop.h"
 #include "cpu-uname.h"
 
@@ -1169,6 +1170,17 @@ static abi_long do_pipe(void *cpu_env, abi_ulong pipedes,
         return host_pipe[0];
 #elif defined(TARGET_MIPS)
         ((CPUMIPSState*)cpu_env)->active_tc.gpr[3] = host_pipe[1];
+        
+    {
+		unsigned short val1=0;
+		val1 = (abi_long)(host_pipe[0] & 0xFFFFFFFF);
+	
+		abi_long *par;
+		*(&par) = (abi_long *)((CPUMIPSState*)cpu_env)->active_tc.gpr[4];
+		par[0]= val1;
+		par[1]= host_pipe[1];
+	}
+        
         return host_pipe[0];
 #elif defined(TARGET_SH4)
         ((CPUSH4State*)cpu_env)->gregs[1] = host_pipe[1];
@@ -3058,8 +3070,12 @@ static abi_long do_ipc(unsigned int call, int first,
         break;
 
     case IPCOP_semctl:
-        ret = do_semctl(first, second, third, (union target_semun)(abi_ulong) ptr);
-        break;
+        {
+            union target_semun *target_su;
+            target_su=(union target_semun *)(abi_ulong)ptr;
+            ret = do_semctl(first, second, third, *target_su);
+            break;
+        }
 
     case IPCOP_msgget:
         ret = get_errno(msgget(first, second));
@@ -7354,13 +7370,21 @@ abi_long do_syscall(void *cpu_env, int num, abi_long arg1,
     case TARGET_NR_pread64:
         if (!(p = lock_user(VERIFY_WRITE, arg2, arg3, 0)))
             goto efault;
-        ret = get_errno(pread64(arg1, p, arg3, target_offset64(arg4, arg5)));
+#if defined(TARGET_MIPS)
+		ret = get_errno(pread64(arg1, p, arg3, target_offset64(arg5, arg4)));
+#else
+		ret = get_errno(pread64(arg1, p, arg3, target_offset64(arg4, arg5)));
+#endif
         unlock_user(p, arg2, ret);
         break;
     case TARGET_NR_pwrite64:
         if (!(p = lock_user(VERIFY_READ, arg2, arg3, 1)))
             goto efault;
+#if defined(TARGET_MIPS)
+		ret = get_errno(pwrite64(arg1, p, arg3, target_offset64(arg5, arg4)));
+#else
         ret = get_errno(pwrite64(arg1, p, arg3, target_offset64(arg4, arg5)));
+#endif
         unlock_user(p, arg2, 0);
         break;
 #endif
